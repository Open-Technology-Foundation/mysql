#!/usr/bin/env bash
#shellcheck disable=SC2034  # Some color variables used conditionally
# MySQL Display Structure Tool - Bash Version
# Format and display MySQL table structure with column alignment, enum handling, and colorized output.
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

VERSION='1.0.0'
SCRIPT_PATH=$(realpath -- "$0")
SCRIPT_DIR=${SCRIPT_PATH%/*}
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- VERSION SCRIPT_PATH SCRIPT_DIR SCRIPT_NAME

# Constants
declare -ir ENUM_WRAP_THRESHOLD=40

# Configuration (modifiable by arguments)
declare -- DATABASE='' FORMAT='table' OUTPUT_FILE=''
declare -a TABLES=() FILTER_COLUMNS=()
declare -i SHOW_STATS=0 NO_COLOR=0

# Data arrays (populated during execution)
declare -a HEADERS=() DATA=() WIDTHS=() ENUM_LINES=()
declare -A STATS=()

# ANSI colors (terminal-aware, can be disabled with NO_COLOR)
declare -- RESET='' BOLD='' RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN=''

init_colors() {
  if [[ -t 1 && -t 2 ]] && ((! NO_COLOR)); then
    RESET=$'\033[0m'
    BOLD=$'\033[1m'
    RED=$'\033[31m'
    GREEN=$'\033[32m'
    YELLOW=$'\033[33m'
    BLUE=$'\033[34m'
    MAGENTA=$'\033[35m'
    CYAN=$'\033[36m'
  fi
}

# Messaging functions
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$SCRIPT_NAME:" msg
  case "$status" in
    info)  prefix+=" ${CYAN}◉${RESET}" ;;
    warn)  prefix+=" ${YELLOW}▲${RESET}" ;;
    error) prefix+=" ${RED}✗${RESET}" ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

info() { >&2 _msg "$@"; }
warn() { >&2 _msg "$@"; }
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-1}"; }
noarg() { (($# > 1)) || die 22 "Option '$1' requires an argument"; }

# Validate MySQL identifier to prevent SQL injection
validate_mysql_identifier() {
  local -- name="$1" type="${2:-identifier}"
  [[ -z $name ]] && die 22 "Empty $type name"
  [[ $name =~ ^[a-zA-Z0-9_\$-]+$ ]] || die 22 "Invalid $type name '$name' (contains unsafe characters)"
}

get_terminal_width() {
  tput cols 2>/dev/null || echo 80
}

usage() {
  cat <<EOF
Usage: $SCRIPT_NAME [OPTIONS] DATABASE TABLE [TABLE...]
       mysql DATABASE -e 'SHOW COLUMNS FROM TABLE' | $SCRIPT_NAME [OPTIONS]

Display MySQL table structure with formatted output.

OPTIONS:
  -c, --columns COLS   Comma-separated list of columns to display
  -f, --format FMT     Output format: table (default), json, csv
  -s, --stats          Show table statistics (row count, size, etc.)
  -n, --no-color       Disable colorized output
  -o, --output FILE    Write output to file (for json/csv formats)
  -h, --help           Display this help message
  -V, --version        Display version information

EXAMPLES:
  $SCRIPT_NAME mydb users
  $SCRIPT_NAME mydb users orders -c Field,Type,Null
  $SCRIPT_NAME mydb users -f json -o structure.json
  $SCRIPT_NAME mydb users -s
  mysql mydb -e 'SHOW COLUMNS FROM users' | $SCRIPT_NAME
EOF
}

# Run MySQL command and capture output
run_mysql_command() {
  local -- database="$1" table="$2"
  local -- output

  if ! output=$(mysql "$database" -e "SHOW COLUMNS FROM \`$table\`" 2>&1); then
    die 1 "MySQL error: $output"
  fi
  echo "$output"
}

# Get table statistics
get_table_stats() {
  local -- database="$1" table="$2"
  local -- result

  STATS=()

  # Row count (backticks for reserved word table names)
  if result=$(mysql "$database" -N -e "SELECT COUNT(*) FROM \`$table\`" 2>/dev/null); then
    STATS[row_count]="${result:-Error}"
  else
    STATS[row_count]="Error"
  fi

  # Table size in MB
  if result=$(mysql "$database" -N -e "SELECT ROUND(((data_length + index_length) / 1024 / 1024), 2) FROM information_schema.TABLES WHERE table_schema = '$database' AND table_name = '$table'" 2>/dev/null); then
    STATS[size_mb]="${result:-Error}"
  else
    STATS[size_mb]="Error"
  fi

  # Index count
  if result=$(mysql "$database" -N -e "SELECT COUNT(*) FROM information_schema.STATISTICS WHERE table_schema = '$database' AND table_name = '$table'" 2>/dev/null); then
    STATS[index_count]="${result:-Error}"
  else
    STATS[index_count]="Error"
  fi
}

# Parse MySQL tab-delimited output into HEADERS and DATA arrays
parse_mysql_output() {
  local -- line
  local -i first=1

  HEADERS=()
  DATA=()

  while IFS= read -r line || [[ -n $line ]]; do
    [[ -z $line ]] && continue

    if ((first)); then
      # First line is headers
      IFS=$'\t' read -ra HEADERS <<< "$line"
      first=0
    else
      # Data rows - store as tab-delimited strings
      DATA+=("$line")
    fi
  done
}

# Apply column filter
apply_column_filter() {
  (( ${#FILTER_COLUMNS[@]} == 0 )) && return 0

  local -a new_headers=() indices=()
  local -i i j found

  # Find indices of requested columns
  for j in "${!FILTER_COLUMNS[@]}"; do
    found=0
    for i in "${!HEADERS[@]}"; do
      if [[ ${HEADERS[i]} == "${FILTER_COLUMNS[j]}" ]]; then
        indices+=("$i")
        new_headers+=("${HEADERS[i]}")
        found=1
        break
      fi
    done
    ((found)) || warn "Column '${FILTER_COLUMNS[j]}' not found"
  done

  (( ${#indices[@]} == 0 )) && die 1 "No valid columns specified"

  # Filter data rows
  local -a new_data=()
  local -- row filtered_row
  local -a fields

  for row in "${DATA[@]}"; do
    IFS=$'\t' read -ra fields <<< "$row"
    filtered_row=""
    for i in "${indices[@]}"; do
      [[ -n $filtered_row ]] && filtered_row+=$'\t'
      filtered_row+="${fields[i]:-}"
    done
    new_data+=("$filtered_row")
  done

  HEADERS=("${new_headers[@]}")
  DATA=("${new_data[@]}")
}

# Calculate column widths
calculate_column_widths() {
  local -i i width max_width
  local -- row cell
  local -a fields

  WIDTHS=()

  # Start with header widths
  for i in "${!HEADERS[@]}"; do
    WIDTHS[i]=${#HEADERS[i]}
  done

  # Check data widths
  for row in "${DATA[@]}"; do
    IFS=$'\t' read -ra fields <<< "$row"
    for i in "${!fields[@]}"; do
      cell="${fields[i]}"

      # For enum types, calculate based on wrapped format
      if [[ $cell == enum\(* ]]; then
        # Find longest enum value + "enum(" prefix
        local -- enum_content longest_val=""
        enum_content="${cell#enum(}"
        enum_content="${enum_content%)}"

        local -- val
        while IFS= read -r -d ',' val || [[ -n $val ]]; do
          val="${val#\'}"
          val="${val%\'}"
          if (( ${#val} > ${#longest_val} )); then
            longest_val="$val"
          fi
        done <<< "${enum_content},"

        width=$(( 6 + ${#longest_val} + 3 ))  # enum( + value + ',)
      else
        width=${#cell}
      fi

      if (( width > WIDTHS[i] )); then
        WIDTHS[i]=$width
      fi
    done
  done

  # Adjust Type column for terminal width
  local -i term_width type_idx=-1 non_type_width=0 available

  for i in "${!HEADERS[@]}"; do
    [[ ${HEADERS[i],,} == type ]] && type_idx=$i
  done

  if (( type_idx >= 0 )); then
    term_width=$(get_terminal_width)
    for i in "${!WIDTHS[@]}"; do
      if (( i != type_idx )); then
        non_type_width+=$(( WIDTHS[i] + 3 ))
      fi
    done
    non_type_width+=4  # Outer pipes

    available=$(( term_width - non_type_width ))
    if (( available > 50 )); then
      available=50
    fi
    if (( available > WIDTHS[type_idx] )); then
      WIDTHS[type_idx]=$available
    fi
  fi
}

# Format enum for multi-line display (populates ENUM_LINES array)
format_enum() {
  local -- enum_str="$1"
  local -i column_width="${2:-50}"

  ENUM_LINES=()

  # Extract enum content
  local -- content
  content="${enum_str#enum(}"
  content="${content%)}"

  # Parse values (handle quoted strings with commas inside)
  local -a values=()
  local -- current="" char
  local -i i in_quote=0

  for (( i=0; i<${#content}; i++ )); do
    char="${content:i:1}"
    if [[ $char == "'" ]]; then
      current+="$char"
      ((in_quote)) && in_quote=0 || in_quote=1
    elif [[ $char == "," ]] && (( !in_quote )); then
      values+=("$current")
      current=""
    else
      current+="$char"
    fi
  done
  [[ -n $current ]] && values+=("$current")

  if (( ${#values[@]} == 0 )); then
    ENUM_LINES=("$enum_str")
    return
  fi

  # Build first line
  local -- first_line="enum(${values[0]}"
  if (( ${#values[@]} > 1 )); then
    first_line+=","
  fi
  ENUM_LINES+=("$first_line")

  # Build subsequent lines
  local -- current_line="" val
  local -i j

  for (( j=1; j<${#values[@]}; j++ )); do
    val="${values[j]}"
    if (( j < ${#values[@]} - 1 )); then
      val+=","
    fi

    if [[ -z $current_line ]]; then
      current_line="$val"
    elif (( ${#current_line} + 1 + ${#val} > column_width )); then
      ENUM_LINES+=("$current_line")
      current_line="$val"
    else
      current_line+=" $val"
    fi
  done

  [[ -n $current_line ]] && ENUM_LINES+=("$current_line")

  # Add closing paren to last line
  local -- last="${ENUM_LINES[-1]}"
  if [[ $last == *, ]]; then
    ENUM_LINES[-1]="${last%,})"
  else
    ENUM_LINES[-1]="${last})"
  fi
}

# Colorize a cell based on header and value
colorize_cell() {
  local -- cell="$1" header="$2"
  local -- header_lower="${header,,}" cell_lower="${cell,,}"

  ((NO_COLOR)) && { echo "$cell"; return; }

  case "$header_lower" in
    key)
      case "$cell" in
        PRI) echo "${BOLD}${RED}${cell}${RESET}" ;;
        UNI) echo "${BOLD}${BLUE}${cell}${RESET}" ;;
        MUL) echo "${BOLD}${GREEN}${cell}${RESET}" ;;
        *)   echo "$cell" ;;
      esac
      ;;
    null)
      case "$cell" in
        NO)  echo "${BOLD}${RED}${cell}${RESET}" ;;
        YES) echo "${GREEN}${cell}${RESET}" ;;
        *)   echo "$cell" ;;
      esac
      ;;
    type)
      if [[ $cell_lower == *int* ]]; then
        echo "${CYAN}${cell}${RESET}"
      elif [[ $cell_lower == *char* || $cell_lower == *text* ]]; then
        echo "${GREEN}${cell}${RESET}"
      elif [[ $cell_lower == *date* || $cell_lower == *time* ]]; then
        echo "${YELLOW}${cell}${RESET}"
      elif [[ $cell_lower == *enum* ]]; then
        echo "${MAGENTA}${cell}${RESET}"
      else
        echo "$cell"
      fi
      ;;
    extra)
      if [[ $cell_lower == *auto_increment* ]]; then
        echo "${BOLD}${YELLOW}${cell}${RESET}"
      else
        echo "$cell"
      fi
      ;;
    *)
      echo "$cell"
      ;;
  esac
}

# Print separator line
print_separator() {
  local -- sep="+"
  local -i i

  for i in "${!WIDTHS[@]}"; do
    sep+=$(printf '%*s' "$(( WIDTHS[i] + 2 ))" '' | tr ' ' '-')
    sep+="+"
  done
  echo "$sep"
}

# Print table statistics
print_stats() {
  (( ${#STATS[@]} == 0 )) && return

  if ((NO_COLOR)); then
    echo "Table Statistics:"
    echo "  Row Count: ${STATS[row_count]:-N/A}"
    echo "  Size: ${STATS[size_mb]:-N/A} MB"
    echo "  Index Count: ${STATS[index_count]:-N/A}"
  else
    echo "${BOLD}Table Statistics:${RESET}"
    echo "  Row Count: ${CYAN}${STATS[row_count]:-N/A}${RESET}"
    echo "  Size: ${CYAN}${STATS[size_mb]:-N/A}${RESET} MB"
    echo "  Index Count: ${CYAN}${STATS[index_count]:-N/A}${RESET}"
  fi
  echo
}

# Print formatted table
print_table() {
  local -i i j type_idx=-1
  local -- row cell colored_cell padding

  # Find Type column index
  for i in "${!HEADERS[@]}"; do
    [[ ${HEADERS[i],,} == type ]] && type_idx=$i && break
  done

  # Print stats if available
  ((SHOW_STATS)) && print_stats

  # Print header separator
  print_separator

  # Print headers
  local -- header_line="|"
  for i in "${!HEADERS[@]}"; do
    if ((NO_COLOR)); then
      printf -v padding "%-${WIDTHS[i]}s" "${HEADERS[i]}"
    else
      printf -v padding "%-${WIDTHS[i]}s" "${HEADERS[i]}"
      padding="${BOLD}${padding}${RESET}"
    fi
    header_line+=" $padding |"
  done
  echo "$header_line"

  # Print header/data separator
  print_separator

  # Print data rows
  local -a fields
  for row in "${DATA[@]}"; do
    IFS=$'\t' read -ra fields <<< "$row"

    # Ensure we have enough fields
    while (( ${#fields[@]} < ${#HEADERS[@]} )); do
      fields+=("")
    done

    # Check for enum that needs wrapping
    local -i has_enum=0 enum_col=-1
    if (( type_idx >= 0 && type_idx < ${#fields[@]} )); then
      cell="${fields[type_idx]}"
      if [[ $cell == enum\(* ]] && (( ${#cell} > ENUM_WRAP_THRESHOLD )); then
        has_enum=1
        enum_col=$type_idx
        format_enum "$cell" "${WIDTHS[type_idx]}"
      fi
    fi

    if (( !has_enum )); then
      # Normal row
      local -- row_line="|"
      for i in "${!fields[@]}"; do
        cell="${fields[i]}"
        colored_cell=$(colorize_cell "$cell" "${HEADERS[i]}")
        printf -v padding "%-${WIDTHS[i]}s" "$cell"
        # Replace plain text with colored version
        if ((NO_COLOR)); then
          row_line+=" $padding |"
        else
          row_line+=" ${colored_cell}$(printf '%*s' "$(( WIDTHS[i] - ${#cell} ))" '') |"
        fi
      done
      echo "$row_line"
    else
      # Multi-line enum row
      local -i line_num
      for line_num in "${!ENUM_LINES[@]}"; do
        local -- row_line="|"
        for i in "${!fields[@]}"; do
          if (( i == enum_col )); then
            cell="${ENUM_LINES[line_num]}"
            if ((NO_COLOR)); then
              printf -v padding "%-${WIDTHS[i]}s" "$cell"
              row_line+=" $padding |"
            else
              row_line+=" ${MAGENTA}${cell}${RESET}$(printf '%*s' "$(( WIDTHS[i] - ${#cell} ))" '') |"
            fi
          else
            if (( line_num == 0 )); then
              cell="${fields[i]}"
              colored_cell=$(colorize_cell "$cell" "${HEADERS[i]}")
              if ((NO_COLOR)); then
                printf -v padding "%-${WIDTHS[i]}s" "$cell"
                row_line+=" $padding |"
              else
                row_line+=" ${colored_cell}$(printf '%*s' "$(( WIDTHS[i] - ${#cell} ))" '') |"
              fi
            else
              # Empty cell for continuation lines
              printf -v padding "%-${WIDTHS[i]}s" ""
              row_line+=" $padding |"
            fi
          fi
        done
        echo "$row_line"
      done
    fi
  done

  # Print footer separator
  print_separator
}

# Export to JSON
export_json() {
  local -- output_file="${1:-}"

  if ! command -v jq >/dev/null 2>&1; then
    die 1 "jq is required for JSON output but not installed"
  fi

  local -- json_array="["
  local -i first_row=1
  local -- row
  local -a fields

  for row in "${DATA[@]}"; do
    IFS=$'\t' read -ra fields <<< "$row"

    ((first_row)) || json_array+=","
    first_row=0

    json_array+="{"
    local -i first_field=1
    local -i i

    for i in "${!HEADERS[@]}"; do
      ((first_field)) || json_array+=","
      first_field=0

      local -- value="${fields[i]:-}"
      # Escape special JSON characters
      value="${value//\\/\\\\}"
      value="${value//\"/\\\"}"
      value="${value//$'\n'/\\n}"
      value="${value//$'\t'/\\t}"

      json_array+="\"${HEADERS[i]}\":\"$value\""
    done
    json_array+="}"
  done
  json_array+="]"

  if [[ -n $output_file ]]; then
    echo "$json_array" | jq '.' > "$output_file"
    echo "JSON data exported to $output_file"
  else
    echo "$json_array" | jq '.'
  fi
}

# Quote CSV field if it contains special characters
_csv_field() {
  local -- field="$1"
  if [[ $field == *,* || $field == *\"* || $field == *$'\n'* ]]; then
    field="${field//\"/\"\"}"  # Escape quotes by doubling
    echo "\"$field\""
  else
    echo "$field"
  fi
}

# Export to CSV
export_csv() {
  local -- output_file="${1:-}"
  local -- output=""

  # Headers
  local -- header_line=""
  local -i i
  for i in "${!HEADERS[@]}"; do
    ((i > 0)) && header_line+=","
    header_line+=$(_csv_field "${HEADERS[i]}")
  done
  output+="$header_line"$'\n'

  # Data rows
  local -- row
  local -a fields
  for row in "${DATA[@]}"; do
    IFS=$'\t' read -ra fields <<< "$row"
    local -- data_line=""
    for i in "${!HEADERS[@]}"; do
      ((i > 0)) && data_line+=","
      data_line+=$(_csv_field "${fields[i]:-}")
    done
    output+="$data_line"$'\n'
  done

  if [[ -n $output_file ]]; then
    printf '%s' "$output" > "$output_file"
    echo "CSV data exported to $output_file"
  else
    printf '%s' "$output"
  fi
}

# Process a single table
process_table() {
  local -- database="$1" table="$2"
  local -- mysql_output

  # Validate identifiers to prevent SQL injection
  validate_mysql_identifier "$database" 'database'
  validate_mysql_identifier "$table" 'table'

  # Get table structure
  mysql_output=$(run_mysql_command "$database" "$table")
  parse_mysql_output <<< "$mysql_output"

  (( ${#HEADERS[@]} == 0 )) && die 1 "Could not parse MySQL output"

  # Get stats if requested
  ((SHOW_STATS)) && get_table_stats "$database" "$table"

  # Apply column filter
  apply_column_filter

  # Calculate widths
  calculate_column_widths

  # Output in requested format
  case "$FORMAT" in
    json) export_json "$OUTPUT_FILE" ;;
    csv)  export_csv "$OUTPUT_FILE" ;;
    *)    print_table ;;
  esac
}

main() {
  # Parse arguments
  while (($#)); do
    case $1 in
      -c|--columns)  noarg "$@"; shift; IFS=',' read -ra FILTER_COLUMNS <<< "$1" ;;
      -f|--format)   noarg "$@"; shift; FORMAT="$1" ;;
      -s|--stats)    SHOW_STATS=1 ;;
      -n|--no-color) NO_COLOR=1 ;;
      -o|--output)   noarg "$@"; shift; OUTPUT_FILE="$1" ;;
      -h|--help)     usage; exit 0 ;;
      -V|--version)  echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
      -*)            die 22 "Invalid option '$1' (use --help)" ;;
      *)             [[ -z $DATABASE ]] && DATABASE="$1" || TABLES+=("$1") ;;
    esac
    shift
  done

  # Initialize colors after parsing (NO_COLOR may be set)
  init_colors

  # Validate format
  case "$FORMAT" in
    table|json|csv) ;;
    *) die 22 "Invalid format '$FORMAT' (use table, json, or csv)" ;;
  esac

  # Handle stdin mode
  if [[ -z $DATABASE ]] && [[ ! -t 0 ]]; then
    parse_mysql_output
    (( ${#HEADERS[@]} == 0 )) && die 1 "Could not parse MySQL output from stdin"
    apply_column_filter
    calculate_column_widths

    case "$FORMAT" in
      json) export_json "$OUTPUT_FILE" ;;
      csv)  export_csv "$OUTPUT_FILE" ;;
      *)    print_table ;;
    esac
    exit 0
  fi

  # Validate arguments
  [[ -z $DATABASE ]] && { usage; die 22 "Database name required"; }
  (( ${#TABLES[@]} == 0 )) && die 22 "At least one table name required"

  # Check mysql client
  command -v mysql >/dev/null 2>&1 || die 1 "MySQL client not found"

  # Process each table
  local -i i
  for i in "${!TABLES[@]}"; do
    # Add separator between tables
    if (( i > 0 )); then
      echo
      echo "================================================================================"
      echo
    fi

    # Print table header
    if ((NO_COLOR)); then
      echo "Database: $DATABASE, Table: ${TABLES[i]}"
    else
      echo "${BOLD}Database:${RESET} $DATABASE, ${BOLD}Table:${RESET} ${TABLES[i]}"
    fi

    process_table "$DATABASE" "${TABLES[i]}"
  done
}

main "$@"

#fin
