#!/bin/bash
# Bash completion for MySQL utilities

_mysql_display_structure() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Available options
    opts="--profile --columns --format --stats --no-color --no-cache --output --version --help"
    short_opts="-p -c -f -s -n -N -o -V -h"

    case "${prev}" in
        --profile|-p)
            # File completion for MySQL config files
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        --format|-f)
            mapfile -t COMPREPLY < <(compgen -W "table json csv" -- "${cur}")
            return 0
            ;;
        --columns|-c)
            # Common MySQL SHOW COLUMNS field names
            mapfile -t COMPREPLY < <(compgen -W "Field Type Null Key Default Extra" -- "${cur}")
            return 0
            ;;
        --output|-o)
            # File completion for output files
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    # Option completion
    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion
    if command -v mysql >/dev/null 2>&1; then
        # Find database argument (first non-option arg after script name)
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile|-c|--columns|-f|--format|-o|--output)
                    ((i++))  # Skip next word (option argument)
                    ;;
                -*)
                    ;;
                *)
                    if [[ -z $database ]]; then
                        database="${COMP_WORDS[i]}"
                    fi
                    ;;
            esac
        done

        if [[ -z $database ]]; then
            # Complete database names
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            # Complete table names
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_tables() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Available options
    opts="--profile --columns --format --stats --no-color --output --version --help"
    short_opts="-p -c -f -s -n -o -V -h"

    case "${prev}" in
        --profile|-p|--output|-o)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        --format|-f)
            mapfile -t COMPREPLY < <(compgen -W "table json csv" -- "${cur}")
            return 0
            ;;
        --columns|-c)
            mapfile -t COMPREPLY < <(compgen -W "Field Type Null Key Default Extra" -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion (same logic as display-structure)
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile|-c|--columns|-f|--format|-o|--output) ((i++)) ;;
                -*) ;;
                *) [[ -z $database ]] && database="${COMP_WORDS[i]}" ;;
            esac
        done

        if [[ -z $database ]]; then
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_databases() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Available options
    opts="--profile --columns --format --stats --no-color --output --version --help"
    short_opts="-p -c -f -s -n -o -V -h"

    case "${prev}" in
        --profile|-p|--output|-o)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        --format|-f)
            mapfile -t COMPREPLY < <(compgen -W "table json csv" -- "${cur}")
            return 0
            ;;
        --columns|-c)
            mapfile -t COMPREPLY < <(compgen -W "Field Type Null Key Default Extra" -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile|-c|--columns|-f|--format|-o|--output) ((i++)) ;;
                -*) ;;
                *) [[ -z $database ]] && database="${COMP_WORDS[i]}" ;;
            esac
        done

        if [[ -z $database ]]; then
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_status() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --verbose --version --help"
    short_opts="-p -v -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac
}

_mysql_users() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --all --version --help"
    short_opts="-p -a -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Complete with usernames from mysql.user
    if command -v mysql >/dev/null 2>&1; then
        local users
        users=$(mysql -N -e "SELECT DISTINCT user FROM mysql.user ORDER BY user" 2>/dev/null)
        mapfile -t COMPREPLY < <(compgen -W "${users}" -- "${cur}")
    fi
}

_mysql_grants() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --all --version --help"
    short_opts="-p -a -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Complete with user@host from mysql.user
    if command -v mysql >/dev/null 2>&1; then
        local users
        users=$(mysql -N -e "SELECT CONCAT(user, '@', host) FROM mysql.user ORDER BY user, host" 2>/dev/null)
        mapfile -t COMPREPLY < <(compgen -W "${users}" -- "${cur}")
    fi
}

_mysql_indexes() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --version --help"
    short_opts="-p -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile) ((i++)) ;;
                -*) ;;
                *) [[ -z $database ]] && database="${COMP_WORDS[i]}" ;;
            esac
        done

        if [[ -z $database ]]; then
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_size() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --version --help"
    short_opts="-p -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile) ((i++)) ;;
                -*) ;;
                *) [[ -z $database ]] && database="${COMP_WORDS[i]}" ;;
            esac
        done

        if [[ -z $database ]]; then
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_updates() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --format --no-color --absolute --output --version --help"
    short_opts="-p -f -n -a -o -V -h"

    case "${prev}" in
        --profile|-p|--output|-o)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
        --format|-f)
            mapfile -t COMPREPLY < <(compgen -W "table json csv" -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table completion
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile|-f|--format|-o|--output) ((i++)) ;;
                -*) ;;
                *) [[ -z $database ]] && database="${COMP_WORDS[i]}" ;;
            esac
        done

        if [[ -z $database ]]; then
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        else
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        fi
    fi
}

_mysql_field_comment() {
    local cur prev opts short_opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--profile --dry-run --version --help"
    short_opts="-p -n -V -h"

    case "${prev}" in
        --profile|-p)
            mapfile -t COMPREPLY < <(compgen -f -- "${cur}")
            return 0
            ;;
    esac

    case "${cur}" in
        -*)
            mapfile -t COMPREPLY < <(compgen -W "${opts} ${short_opts}" -- "${cur}")
            return 0
            ;;
    esac

    # Database/table/field completion
    if command -v mysql >/dev/null 2>&1; then
        local -i i
        local database="" table=""
        for ((i=1; i < COMP_CWORD; i++)); do
            case "${COMP_WORDS[i]}" in
                -p|--profile) ((i++)) ;;
                -*) ;;
                *)
                    if [[ -z $database ]]; then
                        database="${COMP_WORDS[i]}"
                    elif [[ -z $table ]]; then
                        table="${COMP_WORDS[i]}"
                    fi
                    ;;
            esac
        done

        if [[ -z $database ]]; then
            # Complete database names
            local databases
            databases=$(mysql -e "SHOW DATABASES;" 2>/dev/null | tail -n +2 | grep -Ev '^(information_schema|performance_schema|mysql|sys)$')
            mapfile -t COMPREPLY < <(compgen -W "${databases}" -- "${cur}")
        elif [[ -z $table ]]; then
            # Complete table names
            local tables
            tables=$(mysql "${database}" -e "SHOW TABLES;" 2>/dev/null | tail -n +2)
            mapfile -t COMPREPLY < <(compgen -W "${tables}" -- "${cur}")
        else
            # Complete column/field names
            local fields
            fields=$(mysql "${database}" -N -e "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA='${database}' AND TABLE_NAME='${table}'" 2>/dev/null)
            mapfile -t COMPREPLY < <(compgen -W "${fields}" -- "${cur}")
        fi
    fi
}

# Register completion functions
complete -F _mysql_field_comment mysql.field-comment
complete -F _mysql_display_structure mysql.display-structure
complete -F _mysql_tables mysql.tables
complete -F _mysql_databases mysql.databases
complete -F _mysql_indexes mysql.indexes
complete -F _mysql_size mysql.size
complete -F _mysql_updates mysql.updates
complete -F _mysql_status mysql.status
complete -F _mysql_users mysql.users
complete -F _mysql_grants mysql.grants

#fin
